mport tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, BatchNormalization
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint
import matplotlib.pyplot as plt
import numpy as np
import os
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns

class SkinCancerModel:
    def __init__(self, img_size=(224, 224), batch_size=32):
        self.img_size = img_size
        self.batch_size = batch_size
        self.model = None
        self.history = None
        
    def create_model(self):
        """Crear el modelo CNN para clasificación de melanomas"""
        model = Sequential([
            # Primer bloque convolucional
            Conv2D(32, (3, 3), activation='relu', input_shape=(*self.img_size, 3)),
            BatchNormalization(),
            MaxPooling2D(2, 2),
            
            # Segundo bloque convolucional
            Conv2D(64, (3, 3), activation='relu'),
            BatchNormalization(),
            MaxPooling2D(2, 2),
            
            # Tercer bloque convolucional
            Conv2D(128, (3, 3), activation='relu'),
            BatchNormalization(),
            MaxPooling2D(2, 2),
            
            # Cuarto bloque convolucional
            Conv2D(256, (3, 3), activation='relu'),
            BatchNormalization(),
            MaxPooling2D(2, 2),
            
            # Quinto bloque convolucional
            Conv2D(512, (3, 3), activation='relu'),
            BatchNormalization(),
            MaxPooling2D(2, 2),
            
            # Capa de aplanamiento
            Flatten(),
            
            # Capas densas con dropout
            Dense(512, activation='relu'),
            Dropout(0.5),
            Dense(256, activation='relu'),
            Dropout(0.5),
            Dense(128, activation='relu'),
            Dropout(0.3),
            
            # Capa de salida (clasificación binaria)
            Dense(1, activation='sigmoid')
        ])
        
        model.compile(
            optimizer=Adam(learning_rate=0.0001),
            loss='binary_crossentropy',
            metrics=['accuracy']
        )
        
        self.model = model
        return model
    
    def create_data_generators(self, train_dir, test_dir):
        """Crear generadores de datos con data augmentation"""
        # Generador para entrenamiento con data augmentation
        train_datagen = ImageDataGenerator(
            rescale=1./255,
            rotation_range=20,
            width_shift_range=0.2,
            height_shift_range=0.2,
            horizontal_flip=True,
            zoom_range=0.2,
            shear_range=0.2,
            fill_mode='nearest',
            validation_split=0.2  # 20% para validación
        )
        
        # Generador para test sin augmentation
        test_datagen = ImageDataGenerator(rescale=1./255)
        
        # Crear generadores
        train_generator = train_datagen.flow_from_directory(
            train_dir,
            target_size=self.img_size,
            batch_size=self.batch_size,
            class_mode='binary',
            subset='training'
        )
        
        val_generator = train_datagen.flow_from_directory(
            train_dir,
            target_size=self.img_size,
            batch_size=self.batch_size,
            class_mode='binary',
            subset='validation'
        )
        
        test_generator = test_datagen.flow_from_directory(
            test_dir,
            target_size=self.img_size,
            batch_size=self.batch_size,
            class_mode='binary',
            shuffle=False
        )
        
        return train_generator, val_generator, test_generator
    
    def train_model(self, train_generator, val_generator, epochs=50):
        """Entrenar el modelo"""
        if self.model is None:
            self.create_model()
        
        # Callbacks
        callbacks = [
            EarlyStopping(
                monitor='val_loss',
                patience=10,
                restore_best_weights=True,
                verbose=1
            ),
            ReduceLROnPlateau(
                monitor='val_loss',
                factor=0.5,
                patience=5,
                min_lr=1e-7,
                verbose=1
            ),
            ModelCheckpoint(
                'best_model.h5',
                monitor='val_accuracy',
                save_best_only=True,
                verbose=1
            )
        ]
        
        # Entrenar el modelo
        self.history = self.model.fit(
            train_generator,
            epochs=epochs,
            validation_data=val_generator,
            callbacks=callbacks,
            verbose=1
        )
        
        return self.history
    
    def evaluate_model(self, test_generator):
        """Evaluar el modelo en el conjunto de test"""
        # Predicciones
        predictions = self.model.predict(test_generator)
        predicted_classes = (predictions > 0.5).astype(int)
        
        # Clases reales
        true_classes = test_generator.classes
        
        # Métricas
        print("\n=== EVALUACIÓN DEL MODELO ===")
        print(f"Accuracy en test: {np.mean(predicted_classes.flatten() == true_classes):.4f}")
        
        # Reporte de clasificación
        print("\n=== REPORTE DE CLASIFICACIÓN ===")
        print(classification_report(true_classes, predicted_classes.flatten(), 
                                  target_names=['Benigno', 'Maligno']))
        
        # Matriz de confusión
        cm = confusion_matrix(true_classes, predicted_classes.flatten())
        plt.figure(figsize=(8, 6))
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', 
                   xticklabels=['Benigno', 'Maligno'], 
                   yticklabels=['Benigno', 'Maligno'])
        plt.title('Matriz de Confusión')
        plt.ylabel('Valor Real')
        plt.xlabel('Predicción')
        plt.show()
        
        return predicted_classes, true_classes
    
    def plot_training_history(self):
        """Graficar el historial de entrenamiento"""
        if self.history is None:
            print("No hay historial de entrenamiento disponible")
            return
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))
        
        # Accuracy
        ax1.plot(self.history.history['accuracy'], label='Train Accuracy')
        ax1.plot(self.history.history['val_accuracy'], label='Val Accuracy')
        ax1.set_title('Accuracy del Modelo')
        ax1.set_xlabel('Época')
        ax1.set_ylabel('Accuracy')
        ax1.legend()
        ax1.grid(True)
        
        # Loss
        ax2.plot(self.history.history['loss'], label='Train Loss')
        ax2.plot(self.history.history['val_loss'], label='Val Loss')
        ax2.set_title('Loss del Modelo')
        ax2.set_xlabel('Época')
        ax2.set_ylabel('Loss')
        ax2.legend()
        ax2.grid(True)
        
        plt.tight_layout()
        plt.show()
    
    def save_model(self, filepath='skin_cancer_model.h5'):
        """Guardar el modelo entrenado"""
        if self.model is not None:
            self.model.save(filepath)
            print(f"Modelo guardado en: {filepath}")
        else:
            print("No hay modelo para guardar")

# Función principal de entrenamiento
def main():
    # Configurar rutas (ajustar según tu estructura de carpetas)
    train_dir = 'melanoma_cancer_dataset/train'  # Carpeta con 3000 imágenes benignas y 3000 malignas
    test_dir = 'melanoma_cancer_dataset/test'    # Carpeta con 500 imágenes benignas y 500 malignas
    
    # Crear instancia del modelo
    skin_model = SkinCancerModel(img_size=(224, 224), batch_size=32)
    
    # Crear generadores de datos
    print("Creando generadores de datos...")
    train_gen, val_gen, test_gen = skin_model.create_data_generators(train_dir, test_dir)
    
    # Crear y mostrar el modelo
    print("Creando modelo...")
    model = skin_model.create_model()
    print(model.summary())
    
    # Entrenar el modelo
    print("Iniciando entrenamiento...")
    history = skin_model.train_model(train_gen, val_gen, epochs=50)
    
    # Mostrar gráficos de entrenamiento
    skin_model.plot_training_history()
    
    # Evaluar el modelo
    print("Evaluando modelo...")
    skin_model.evaluate_model(test_gen)
    
    # Guardar el modelo
    skin_model.save_model('skin_cancer_model.h5')
    
    print("\n¡Entrenamiento completado!")

if __name__ == "__main__":
    main()
